<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TDrunk</title>
  
  <subtitle>Had I not seen the sun, I could have borne the shade</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://RosamondTao.github.io/"/>
  <updated>2019-02-13T14:20:44.906Z</updated>
  <id>https://RosamondTao.github.io/</id>
  
  <author>
    <name>TDrunk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一篇文章超快速复习C++</title>
    <link href="https://RosamondTao.github.io/2019/02/13/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%B6%85%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0C/"/>
    <id>https://RosamondTao.github.io/2019/02/13/一篇文章超快速复习C/</id>
    <published>2019-02-13T13:01:32.000Z</published>
    <updated>2019-02-13T14:20:44.906Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/13/一篇文章超快速复习C/fengmian.jpg" alt="git1"></p><a id="more"></a><blockquote><p>是<strong>复习</strong>哈。任性的我绝不会把写过程序的人都会的那些语法重复记录的！</p></blockquote><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是块注释(块注释不可嵌套)*/</span></span><br><span class="line"><span class="comment">//这是行注释</span></span><br></pre></td></tr></table></figure><p>此外，还可使用 <code>#if 0 ... #endif</code> 来实现注释，且可以嵌套，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> condition</span></span><br><span class="line">    code</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><h3 id="2-基本内置类型"><a href="#2-基本内置类型" class="headerlink" title="2. 基本内置类型"></a>2. 基本内置类型</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">布尔型</td><td style="text-align:center">bool</td></tr><tr><td style="text-align:center">字符型</td><td style="text-align:center">char</td></tr><tr><td style="text-align:center">整型</td><td style="text-align:center">int</td></tr><tr><td style="text-align:center">浮点型</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">双浮点型</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">无类型</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">宽字符型</td><td style="text-align:center">wchar_t</td></tr></tbody></table><p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p><ul><li>signed</li><li>unsigned</li><li>short</li><li>long</li></ul><h3 id="3-typedef声明"><a href="#3-typedef声明" class="headerlink" title="3. typedef声明"></a>3. typedef声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> feet; <span class="comment">//定义feet为int的另一个叫法</span></span><br><span class="line">feet distance; <span class="comment">//整型变量distance</span></span><br></pre></td></tr></table></figure><h3 id="4-C-常量"><a href="#4-C-常量" class="headerlink" title="4. C++常量"></a>4. C++常量</h3><p>(1) 整数常量<br>整数常量可以是十进制、八进制或十六进制的常量。<br>前缀指定基数：<code>0x</code>和<code>0X</code>表十六进制，0表八进制，不带前缀则默认表示十进制。<br>后缀指定基数：<code>U</code>或<code>u</code>表符号整数(unsigned).<code>L</code>或<code>l</code>表长整数(long)，后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p><p>(2) 字符常量<br><code>L&#39;...&#39;</code>为宽字符常量，必须存储在<code>wchar_t</code>类型变量中，否则为窄字符常量。</p><p>(3) 定义常量</p><ul><li>#define 预处理器 （eg: #define LENGTH 10） </li><li>const 关键字  (const前缀声明指定类型常量 eg: const int LENGTH 10)</li></ul><h3 id="5-C-存储类"><a href="#5-C-存储类" class="headerlink" title="5.C++存储类"></a>5.C++存储类</h3><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p><table><thead><tr><th style="text-align:center">存储类</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">auto</td><td style="text-align:center">根据初始化表达式自动推断被声明的变量的类型 (eg: auto f = 3.14; //double)</td></tr><tr><td style="text-align:center">register</td><td style="text-align:center">register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。寄存器只用于需要快速访问的变量，比如计数器。</td></tr><tr><td style="text-align:center">static</td><td style="text-align:center">指示编译器在程序的生命周期内保持局部变量的存在。使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</td></tr><tr><td style="text-align:center">extern</td><td style="text-align:center">extern 是用来在另一个文件中声明一个全局变量或函数。extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。</td></tr><tr><td style="text-align:center">mutable</td><td style="text-align:center">它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</td></tr><tr><td style="text-align:center">thread_local</td><td style="text-align:center">使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。</td></tr></tbody></table><h3 id="6-函数形参"><a href="#6-函数形参" class="headerlink" title="6.函数形参"></a>6.函数形参</h3><p>(1) 传值调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//声明</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(a, b);  <span class="comment">//调用</span></span><br></pre></td></tr></table></figure><p>这种调用方式把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</p><p>(2) 指针调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>; <span class="comment">//声明</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(&amp;a, &amp;b);  <span class="comment">//调用</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内容</span></span><br><span class="line">temp = *x;  <span class="comment">//*x表取x指针指向的值</span></span><br><span class="line">*x = *y;</span><br><span class="line">*y = temp;</span><br></pre></td></tr></table></figure><p>这种调用方式把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</p><p>(3) 引用调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>; <span class="comment">//声明</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(a, b);  <span class="comment">//调用</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内容</span></span><br><span class="line">temp = x;  <span class="comment">//x表a变量的别名</span></span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br></pre></td></tr></table></figure><p>该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</p><h3 id="7-数组"><a href="#7-数组" class="headerlink" title="7.数组"></a>7.数组</h3><p>(1) 一维数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> balance[<span class="number">10</span>];  <span class="comment">//类型为double包含10个元素的数组</span></span><br><span class="line"><span class="comment">//double balance[10] = &#123;1000.0,2,400,7.0&#125;;  //也可直接初始化</span></span><br><span class="line">balance[<span class="number">3</span>] = <span class="number">1</span>;  <span class="comment">//赋值数组中第4个数为1</span></span><br></pre></td></tr></table></figure></p><p>(2) 二维数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;      <span class="comment">//初始化法一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;    <span class="comment">//初始化法二</span></span><br></pre></td></tr></table></figure></p><p>(3) 指向数组的指针<br>数组名是指向数组中第一个元素的常量指针（数组本身也是一个常量指针）。即balance是一个指向&amp;balance[0]的指针。<br>除此外，*(balance+4)是一种访问balance[4]的合法方式。</p><blockquote><p>注意：<br>    <em>(balance+1)  正确    </em>(balance++)  错误 （因为balance++相当于balance=balance+1，而数组名作为常量是不可改变的）</p></blockquote><p>(4) 传递数组给函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *param)</span></span>;  <span class="comment">//方法一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> param[<span class="number">10</span>])</span></span>;  <span class="comment">//方法二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> param[])</span></span>;  <span class="comment">//方法三</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun(balance);  <span class="comment">//调用</span></span><br></pre></td></tr></table></figure><p>(5) 从函数返回数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回数组的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> r;  <span class="comment">//r为数组名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = fun();</span><br></pre></td></tr></table></figure><h3 id="8-字符串"><a href="#8-字符串" class="headerlink" title="8.字符串"></a>8.字符串</h3><p>C++提供了2种类型的字符串表示形式：</p><p>(1) C风格字符串<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><p>(2) C++中的String类</p><p>C++标准库提供了string类类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   //包含包</span></span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello"</span>;  <span class="comment">//定义</span></span><br></pre></td></tr></table></figure></p><h3 id="9-指针"><a href="#9-指针" class="headerlink" title="9.指针"></a>9.指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;  <span class="comment">//一个整型的指针</span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">20</span>;  <span class="comment">//变量var</span></span><br><span class="line">ip = &amp;var;  <span class="comment">//*ip(值为20，即为var)</span></span><br></pre></td></tr></table></figure><p>(1) C++ NULL指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = <span class="literal">NULL</span>;  <span class="comment">//将无确切地址可赋的指针初始化为NULL</span></span><br><span class="line"><span class="keyword">if</span>(ptr)&#123;...&#125;  <span class="comment">//若ptr非空</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)&#123;...&#125;  <span class="comment">//若ptr空</span></span><br></pre></td></tr></table></figure></p><p>(2) 指针的算术运算<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line"><span class="keyword">int</span> var[MAX] = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>&#125;;</span><br><span class="line">ptr = var;  <span class="comment">//数组名为常量指针不可直接进行算术运算</span></span><br><span class="line">ptr++;  <span class="comment">//递增指针</span></span><br><span class="line">ptr--;  <span class="comment">//递减指针</span></span><br><span class="line"><span class="keyword">if</span>(ptr&lt;=&amp;var[MAX<span class="number">-1</span>])&#123;...&#125; <span class="comment">//指针比较</span></span><br></pre></td></tr></table></figure></p><p>(3) 指针数组</p><p>指针数组本质为存储指针的数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *names[MAX] = &#123;</span><br><span class="line">    <span class="string">"Zara Ali"</span>,<span class="string">"Hina Ali"</span>,<span class="string">"Nuha Ali"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(4) 指向指针的指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **var;</span><br></pre></td></tr></table></figure></p><p>(5) 传递指针给函数</p><p>（见 <em>6.函数形参-&gt;指针调用</em> ）</p><p>(6) 从函数返回指针</p><p>（同 <em>7.数组-&gt;从函数返回数组</em>）</p><h3 id="10-引用"><a href="#10-引用" class="headerlink" title="10.引用"></a>10.引用</h3><p>(1) 引用VS指针</p><ul><li>不存在空引用</li><li>一旦引用被初始化为一个对象，就不可被指向到另一对象</li><li>引用必须在被创建时初始化</li></ul><p>(2) 创建引用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; r = i;  <span class="comment">//为i声明并初始化引用变量</span></span><br></pre></td></tr></table></figure></p><p>(3) 把引用作为参数<br>（见 <em>6.函数形参-&gt;引用调用</em>）</p><p>(4) 把引用作为返回值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> vals[] = &#123;<span class="number">10.1</span>,<span class="number">12.6</span>,<span class="number">33.1</span>&#125;;  <span class="comment">//初始化一个全局数组</span></span><br><span class="line"><span class="function"><span class="keyword">double</span>&amp; <span class="title">setValues</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;  <span class="comment">//定义一个返回引用的函数</span></span><br><span class="line">    <span class="keyword">return</span> vals[i];</span><br><span class="line">&#125;</span><br><span class="line">setValues(<span class="number">1</span>) = <span class="number">20.23</span>;  <span class="comment">//调用，结果将vals[1]值改为20.23</span></span><br></pre></td></tr></table></figure></p><h3 id="11-数据结构"><a href="#11-数据结构" class="headerlink" title="11.数据结构"></a>11.数据结构</h3><p>(1) 定义结构<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接定义一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> book_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体并声明一个变量book</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> book_id;</span><br><span class="line">&#125;book;</span><br></pre></td></tr></table></figure></p><p>(2) 访问结构成员<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Books book1;  <span class="comment">//声明一个Books类型变量</span></span><br><span class="line">book1.book_id = <span class="number">7</span>;  <span class="comment">//访问成员</span></span><br></pre></td></tr></table></figure></p><p>(3) 结构作为函数参数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">(struct Books book)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line">printBook(book1);  <span class="comment">//调用</span></span><br></pre></td></tr></table></figure></p><p>(4) 指向结构的指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">s_p</span>;</span>  <span class="comment">//声明一个指向Books类型的指针</span></span><br><span class="line">s_p = &amp;book1;  <span class="comment">//初始化</span></span><br><span class="line">s_p-&gt;title = <span class="string">"相对论"</span>;  <span class="comment">//访问成员</span></span><br></pre></td></tr></table></figure></p><h2 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h2><h3 id="12-类-amp-对象"><a href="#12-类-amp-对象" class="headerlink" title="12.类&amp;对象"></a>12.类&amp;对象</h3><p>(1) 类定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>(2) 对象定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box Box1;</span><br><span class="line">Box Box2;</span><br></pre></td></tr></table></figure></p><p>(3) 类成员</p><p>类成员包括数据成员和成员函数，数据成员这里不再详写。<br>类成员函数有两种定义方法：类内定义、类外定义<br><strong>类内定义</strong><br>在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>类外定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;         <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;        <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;         <span class="comment">// 高度</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 返回体积</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">double</span> Box::getVolume(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在项目中，将类的声明（有可能会有类内定义）写在.h头文件中，将类外定义写在对应的.cpp源文件中。</p><p>(4) 类构造函数&amp;析构函数</p><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带参数构造函数</span></span><br><span class="line">Line::Line( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带初始化列表的构造函数</span></span><br><span class="line">Line::Line( <span class="keyword">double</span> len): length(len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line::~Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being deleted"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5) 友元函数<br>该函数不属于任何类，但类可以在本身声明其为友元而使其获得访问类内<code>private</code>和<code>protected</code>的权限。<br>注意：友元函数并非类的成员，故没有this指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">double</span> width;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请注意：printWidth() 不是任何类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Width of box : "</span> &lt;&lt; box.width &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除友元函数外也有友元类，只需在类c1中声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">c2</span>;</span></span><br></pre></td></tr></table></figure></p><p>即可将类c2声明为友元类，使c2中的所有成员函数均有访问c1的<code>private</code>和<code>protected</code>的权限。</p><p>(6) this指针<br>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p><p>(7) 类的静态成员<br>我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。<br>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化。<br>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。<br>以下示例帮助理解：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      Box(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;<span class="string">"Constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         length = l;</span><br><span class="line">         breadth = b;</span><br><span class="line">         height = h;</span><br><span class="line">         <span class="comment">// 每次创建对象时增加 1</span></span><br><span class="line">         objectCount++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> objectCount;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;     <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;    <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;     <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化类 Box 的静态成员</span></span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 在创建对象之前输出对象的总数</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inital Stage Count: "</span> &lt;&lt; Box::getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function">Box <span class="title">Box1</span><span class="params">(<span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">1.5</span>)</span></span>;    <span class="comment">// 声明 box1</span></span><br><span class="line">   <span class="function">Box <span class="title">Box2</span><span class="params">(<span class="number">8.5</span>, <span class="number">6.0</span>, <span class="number">2.0</span>)</span></span>;    <span class="comment">// 声明 box2</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 在创建对象之后输出对象的总数</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Final Stage Count: "</span> &lt;&lt; Box::getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="13-继承"><a href="#13-继承" class="headerlink" title="13. 继承"></a>13. 继承</h3><p>一个类可以派生自多个类，且有public、private、protected这3种继承类型，默认private<br>语法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>派生类可以访问基类中所有的非私有成员。</p><p>一个派生类继承了所有的基类方法，但下列情况除外：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><h3 id="14-重写和重载"><a href="#14-重写和重载" class="headerlink" title="14.重写和重载"></a>14.重写和重载</h3><p>方法重载是指同一个类中的多个方法具有相同的名字,但这些方法具有不同的参数列表,即参数的数量或参数类型不能完全相同。<br>方法重写是存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型。</p><h3 id="15-多态"><a href="#15-多态" class="headerlink" title="15.多态"></a>15.多态</h3><p>C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行处于不同类中的同名成员函数。</p><p>(1) 虚函数<br>在基类中被派生类再定义的某函数fun(),前加virtual,则该函数即为虚函数。这样的操作可以告诉编译器不要静态链接到该函数（所谓静态链接即只根据指针类型来确定调用的函数是基类中的fun()还是派生类中的fun()），而是动态链接（动态链接则是在程序中任意点可以根据所调用的对象类型来选择调用的函数）。综上，就是让编译器看指针的内容，而不是它的类型来决定到底调用谁的fun()。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2) 纯虚函数<br>以上虚函数若无法给出具体的定义，这是就会用到纯虚函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>；</span><br></pre></td></tr></table></figure></p><h3 id="16-数据封装和数据抽象"><a href="#16-数据封装和数据抽象" class="headerlink" title="16.数据封装和数据抽象"></a>16.数据封装和数据抽象</h3><p>数据封装是一种把数据和操作数据的函数捆绑在一起的机制。<br>数据抽象是一种仅向用户暴漏接口而把具体的实现细节隐藏的机制。<br>具体在实践中了解。</p><h3 id="17-接口（抽象类）"><a href="#17-接口（抽象类）" class="headerlink" title="17.接口（抽象类）"></a>17.接口（抽象类）</h3><p>若类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。<br>抽象类（ABC），不能被用于实例化对象，派生自抽象类的类必须重写纯虚函数，才可以被实例化。</p><hr><p>参考内容：</p><blockquote></blockquote><ul><li><a href="http://www.runoob.com/cplusplus/cpp-tutorial.html" target="_blank" rel="noopener">C++教程</a></li><li><a href="https://www.cnblogs.com/upcwanghaibo/p/6527354.html" target="_blank" rel="noopener">重载与重写的区别</a></li><li><a href="https://www.cnblogs.com/fenghuan/p/4794514.html" target="_blank" rel="noopener">C++中的头文件(.h)和源文件(.cpp)都该写些什么</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/02/13/一篇文章超快速复习C/fengmian.jpg&quot; alt=&quot;git1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://RosamondTao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://RosamondTao.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>git与github使用总结</title>
    <link href="https://RosamondTao.github.io/2018/12/06/git%E4%B8%8Egithub%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://RosamondTao.github.io/2018/12/06/git与github使用总结/</id>
    <published>2018-12-06T13:24:42.000Z</published>
    <updated>2018-12-07T04:14:19.116Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统。<br>gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。</p><a id="more"></a><h2 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h2><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1. 创建仓库"></a>1. 创建仓库</h3><p>首先cd到需要建为仓库的目录下，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git1.png" alt="git1"></p><p>以上即为创建空仓库成功，此时该目录下将出现一个.git目录(默认隐藏)。</p><p>这里首先须知git版本控制系统一个非常重要的内容，方便后面命令的理解，用一张图表示如下：<br><img src="/2018/12/06/git与github使用总结/git0.png" alt="git0"></p><p>其中工作区即为电脑中要创建仓库的目录（即为我这里使用的/e/GIT/learngit目录），当成功创建仓库后，形成的.git目录，即为Git的版本库。</p><h3 id="2-添加或删除文件到版本库"><a href="#2-添加或删除文件到版本库" class="headerlink" title="2. 添加或删除文件到版本库"></a>2. 添加或删除文件到版本库</h3><p>此过程需要两步。<br>(1) 添加文件到仓库或从仓库删除已有文件（从工作区到暂存区）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add tips.txt</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git2.png" alt="git2"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br></pre></td></tr></table></figure></p><p>执行后若没有提示即为添加文件成功</p><p>(2) 提交文件到仓库（从暂存区到分支）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a tips file&quot;</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git3.png" alt="git3"><br>-m 后的为输入的本次提交说明，这样你就能从历史记录里方便地找到改动记录。</p><h3 id="3-查看工作区当前状态与具体修改内容"><a href="#3-查看工作区当前状态与具体修改内容" class="headerlink" title="3. 查看工作区当前状态与具体修改内容"></a>3. 查看工作区当前状态与具体修改内容</h3><p>对tips.txt做修改，加入一行文字，然后执行如下命令查看状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git4.png" alt="git4"><br>结果如上图，显示tips.txt被修改，但没有提交。如需知道具体修改了什么，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git5.png" alt="git5">  </p><p>然后首先add再commit,提交完成后再查看工作区状态如下：<br><img src="/2018/12/06/git与github使用总结/git6.png" alt="git6">  </p><p>注意：</p><ul><li>要随时掌握工作区的状态，使用git status命令。</li><li>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</li></ul><h3 id="4-版本回退与恢复"><a href="#4-版本回退与恢复" class="headerlink" title="4. 版本回退与恢复"></a>4. 版本回退与恢复</h3><p>首先需要知道，每个版本都有一个版本号，我们可以通过每个版本的版本号来改变指针指向，从而做到版本之间的穿梭。<br>查看版本号的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git7.png" alt="git7"><br>一种更漂亮的输出方式：<br><img src="/2018/12/06/git与github使用总结/git8.png" alt="git8"> </p><p>其中黄色的一大串的十六进制数字即为版本号commit_id。通过版本号利用如下命令可以穿梭到任何版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard commit_id</span><br></pre></td></tr></table></figure><p>除此外，一种相对当前版本的穿梭方式为使用HEAD^(上一版本)，HEAD^^(上上版本)……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git9.png" alt="git9"> </p><p>若已经回退回之前版本，再使用git log则不会显示回退到的版本之后的版本，此时可使用如下命令查看之前操作，查阅版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git10.png" alt="git10"><br>其中，蓝色框部分即为新版本(modifytest2)的commit_id号，要从老版本到新版本只需再执行git reset即可。</p><h3 id="5-工作区与暂存区修改回退（丢弃修改）"><a href="#5-工作区与暂存区修改回退（丢弃修改）" class="headerlink" title="5. 工作区与暂存区修改回退（丢弃修改）"></a>5. 工作区与暂存区修改回退（丢弃修改）</h3><p>若需回退的文件还在工作区，并未add到暂存区，则除了手动删除刚才的修改（包括删除文件等操作）或者使用ctrl+z以外，可以使用如下命令恢复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- tips.txt</span><br></pre></td></tr></table></figure><p>意思为将tips.txt文件在工作区的修改全部撤销，即回到最近一次commit或add时的状态。</p><p>若需回退的文件已add到了暂存区，则可使用如下命令将暂存区的修改撤销，重新放回工作区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD tips.txt</span><br></pre></td></tr></table></figure><p>然后再按照前面所说工作区的清除方式撤销修改。</p><p>ps:若已经commit，则使用版本回退方式。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库使用github，这里默认你已经有了一个github账户。</p><h3 id="1-SSH-key创建与使用"><a href="#1-SSH-key创建与使用" class="headerlink" title="1. SSH key创建与使用"></a>1. SSH key创建与使用</h3><p>(1) 创建SSH key。<br>在用户主目录下，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>邮件地址换为自己地址后，一路回车即可。成功后在用户主目录下会生成一个.ssh目录，目录中有里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>(2) 将公钥告知github<br>GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。具体方法如下图：<br><img src="/2018/12/06/git与github使用总结/git11.png" alt="git11"> </p><h3 id="2-添加远程库"><a href="#2-添加远程库" class="headerlink" title="2. 添加远程库"></a>2. 添加远程库</h3><p>在github页面，“Create a new repo”创建一个新的仓库，命名(最好与要关联的本地仓库命名一样方便管理)后，“Create repository”即可创建成功。如下图：<br><img src="/2018/12/06/git与github使用总结/git12.png" alt="git12"> </p><p>(1) 将本地仓库关联到远程库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:RosamondTao/learngit.git</span><br></pre></td></tr></table></figure><p>(2) 推送本地内容到远程库上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git13.png" alt="git13"> </p><p>第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化该命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>(3) 将远程仓库克隆到本地<br>现有本地库，再有远程库，则使用以上方法关联。若从零开始创建远程库，再要有一个本地的仓库的话，则需要从远程库克隆，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:RosamondTao/gitskills.git</span><br></pre></td></tr></table></figure><p><img src="/2018/12/06/git与github使用总结/git14.png" alt="git14"></p><h2 id="git分支-基础操作"><a href="#git分支-基础操作" class="headerlink" title="git分支(基础操作)"></a>git分支(基础操作)</h2><h3 id="1-查看分支："><a href="#1-查看分支：" class="headerlink" title="1. 查看分支："></a>1. 查看分支：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><h3 id="2-创建分支："><a href="#2-创建分支：" class="headerlink" title="2. 创建分支："></a>2. 创建分支：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;name&gt;</span><br></pre></td></tr></table></figure><h3 id="3-切换分支："><a href="#3-切换分支：" class="headerlink" title="3. 切换分支："></a>3. 切换分支：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;name&gt;</span><br></pre></td></tr></table></figure><h3 id="4-创建-切换分支："><a href="#4-创建-切换分支：" class="headerlink" title="4. 创建+切换分支："></a>4. 创建+切换分支：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;name&gt;</span><br></pre></td></tr></table></figure><h3 id="5-合并某分支到当前分支："><a href="#5-合并某分支到当前分支：" class="headerlink" title="5. 合并某分支到当前分支："></a>5. 合并某分支到当前分支：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;name&gt;</span><br></pre></td></tr></table></figure><h3 id="6-删除分支："><a href="#6-删除分支：" class="headerlink" title="6. 删除分支："></a>6. 删除分支：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="参与开源项目"><a href="#参与开源项目" class="headerlink" title="参与开源项目"></a>参与开源项目</h2><p>详见廖雪峰的网站<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137628548491051ccfaef0ccb470894c858999603fedf000" target="_blank" rel="noopener">使用GitHub</a></p><p>以上为本人学习github的一些总结，只满足于本人目前简单的需求。详细讲解推荐廖雪峰的官方网站<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a>，该教程讲解细致，浅显易懂，对我有很大帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是目前世界上最先进的分布式版本控制系统。&lt;br&gt;gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。&lt;/p&gt;
    
    </summary>
    
      <category term="实用指南" scheme="https://RosamondTao.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="git" scheme="https://RosamondTao.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>倒排索引</title>
    <link href="https://RosamondTao.github.io/2018/11/18/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    <id>https://RosamondTao.github.io/2018/11/18/倒排索引/</id>
    <published>2018-11-18T06:00:40.000Z</published>
    <updated>2018-12-06T14:16:30.343Z</updated>
    
    <content type="html"><![CDATA[<p>倒排索引是现代信息检索系统的核心部分。</p><p>Web信息检索不是简单地<strong>在一个文档中查找指定的词</strong>，而是需要<strong>利用指定的词找出所有包含该词语的文档</strong>。</p><a id="more"></a><h2 id="文档信息索引"><a href="#文档信息索引" class="headerlink" title="文档信息索引"></a>文档信息索引</h2><h3 id="1-在一个文档中找指定的词"><a href="#1-在一个文档中找指定的词" class="headerlink" title="1. 在一个文档中找指定的词"></a>1. 在一个文档中找指定的词</h3><p>可以看成是一个子串匹配问题。由Knuth，Morris，Pratt共同提出的KMP算法，是一个非常优秀的子串匹配算法，它对于各种情况，都可以在线性时间内完成匹配查找。<br>但是如果对海量文档中每一个文档运行一次KMP匹配算法，将是一个不可接受的时间开销。</p><h3 id="2-利用指定的词找出所有包含该词语的文档"><a href="#2-利用指定的词找出所有包含该词语的文档" class="headerlink" title="2. 利用指定的词找出所有包含该词语的文档"></a>2. 利用指定的词找出所有包含该词语的文档</h3><p>采用倒排索引。原理：在检索之前，首先用一个数据结构存储了包含每个检索词的对应文档集合，那么检索效率将会急剧提高。<br>倒排索引主要由词典和倒排链两个部分组成。词典记录了需要被检索的所有词条项和对应倒排链指针。对于一个查询词条项，查找其是否出现在词典中，如果找到就可以直接获取到倒排链指针，也就是就直接快速获取到了文档集合。为了满足快速索引构建和词项查找需求，词典本身通常是<strong>利用Hash表</strong>或者<strong>二叉搜索树</strong>实现；出现在词典中的每个词项都对应一个倒排链，最简单的倒排链存储了包含该此项的所有文档ID列表。</p><p>哈希表方法图示（详见参考网址）：<br><img src="/2018/11/18/倒排索引/AVL.png" alt="AVL"><br>AVL树方法图示（详见参考网址）：<br><img src="/2018/11/18/倒排索引/hash.png" alt="hash"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>考虑将该方法使用于曲线匹配上。<br>曲线的表示形式为列表，数值为在1080*1920的图片上像素值。映射如下：</p><blockquote><p>整条曲线-&gt;文档<br>需匹配曲线片段-&gt;要找的指定的词</p></blockquote><p>问题：<br>实际中在曲线上的匹配大多为模糊匹配，需要考虑曲线平移旋转等各种问题。这种利用倒排索引来大规模匹配的方法在曲线旋转角度过大或上下平移过严重的情况下并不适用，文献[Image Based Geo-localization in the Alps]中的方法复现后对于这种情况效果并不理想，在其基础上考虑改进。</p><p><em>未完待续。。。</em></p><h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><blockquote><ul><li><a href="http://zhhz.suda.edu.cn/aa/a9/c3892a43689/page.htm" target="_blank" rel="noopener">http://zhhz.suda.edu.cn/aa/a9/c3892a43689/page.htm</a></li><li><a href="https://blog.csdn.net/u011239443/article/details/60604017" target="_blank" rel="noopener">https://blog.csdn.net/u011239443/article/details/60604017</a></li><li><a href="http://xueshu.baidu.com/usercenter/paper/show?paperid=cb65783b444c2229583f048854c5c54e&amp;site=xueshu_se&amp;hitarticle=1" target="_blank" rel="noopener">http://xueshu.baidu.com/usercenter/paper/show?paperid=cb65783b444c2229583f048854c5c54e&amp;site=xueshu_se&amp;hitarticle=1</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;倒排索引是现代信息检索系统的核心部分。&lt;/p&gt;
&lt;p&gt;Web信息检索不是简单地&lt;strong&gt;在一个文档中查找指定的词&lt;/strong&gt;，而是需要&lt;strong&gt;利用指定的词找出所有包含该词语的文档&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://RosamondTao.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构&amp;算法" scheme="https://RosamondTao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
      <category term="project(master)" scheme="https://RosamondTao.github.io/tags/project-master/"/>
    
  </entry>
  
  <entry>
    <title>thinking</title>
    <link href="https://RosamondTao.github.io/2018/10/18/thinking/"/>
    <id>https://RosamondTao.github.io/2018/10/18/thinking/</id>
    <published>2018-10-18T15:17:01.000Z</published>
    <updated>2018-10-18T15:35:05.596Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="测试" scheme="https://RosamondTao.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="emmmm" scheme="https://RosamondTao.github.io/tags/emmmm/"/>
    
      <category term="yoooo" scheme="https://RosamondTao.github.io/tags/yoooo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://RosamondTao.github.io/2018/10/11/hello-world/"/>
    <id>https://RosamondTao.github.io/2018/10/11/hello-world/</id>
    <published>2018-10-11T13:40:44.008Z</published>
    <updated>2018-10-17T16:14:11.627Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="IM-GENIUS"><a href="#IM-GENIUS" class="headerlink" title="IM GENIUS"></a>IM GENIUS</h2><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;IM-GENIUS&quot;&gt;&lt;a href=&quot;#IM-GENIUS&quot; class=&quot;headerlink&quot; title=&quot;IM GENIUS&quot;&gt;&lt;/a&gt;IM GENIUS&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
